BattleManager
　PlayerUpdate()の中身作成
　　カードの使用やアクション、自ターン終了処理
　EnemyUpdate()の中身作成
　　ランダムのカードの使用、全エネミーの行動修了確認後　エネミーターン終了

Player（）
　Update（）
　　カードの選択（カーソルが合う、クリック判定）
　　アクション（座標移動）

Enemy（）
　カードを確認、ランダム処理
　アクション（座標移動）

ダメージ計算
damage = (ATK(MAG) * Card% * K) - (DEF * D)

バトル開始前
　エネミーの生成
　デッキの生成
バトル開始
　ターン開始処理
	コストの初期化
	手札の補充

	2026/01/08
	現状の進捗
	・sceneの切り替え完了
	・Battlesystemのプレイヤー部分の基礎完成
	・プレイヤーとカードの仮実装
	・Enemyの仮実装
	・ターン制の基礎完成

	今後の予定
	・カード選択時、ターン終了時のUI実装
	・山札からカードがなくなったとき、エラーが発生するため、修正
	・Playerの行動実装	
	・Enemyの行動実装
	・カードの使用時メソッドの実装
	・UIの実装
	・エフェクトの実装
	・バランス調整
	
	キャラクターとアニメーションの同期実装
	 ・データにテクスチャーキーを追加
	 ・ファクトリークラスでテクスチャーキーを受け取り、アニメーション生成時に反映させる

	 #pragma once
#include<SFML/Graphics.hpp>
#include <iostream>
#include <memory>
#include <vector>
#include <optional>
#include "ActionData.h"
#include "../../Character/Character.h"
#include "../../Card/Card.h"
#include "../SelectTarget/TargetSelect.h"
#include "../../UI/CircleButton.h"

// プレイヤー選択フェーズ
enum class PlayerSelectPhase
{
    SELECT_CARD,
    SELECT_TARGET,
    CONFIRM
};

class UserController
{
public:

    // コンストラクタ
    UserController();

    // アクションキャラのセット
    void SetActionCharacter(const std::shared_ptr<Character>& character);
    // ターゲット候補のセット
    void SetTargetCandidates(const std::vector<std::shared_ptr<Character>>& targets);
    // 選択カードインデックスの取得
	int GetSelectedCardIndex() const { return m_selectedCardIndex; }
    // 更新
    void Update(sf::RenderWindow& window);
	// 描画
    void Draw(sf::RenderWindow& window) const;
	// アクションがあるか
    bool HasAction() const;
	// アクションの取得とリセット
    Action PopAction();
    // ターン終了ボタン用
    bool IsTurnEndRequested() const;
	// ターン終了要求リセット
    void ResetTurnEndRequest();

private:
    // 現在のフェーズ
    PlayerSelectPhase m_phase;
    // アクションキャラ
    std::shared_ptr<Character> m_actionCharacter;
    // 選択カード
    std::optional<CardData> m_selectedCard;
    // 選択カードのindex
    int m_selectedCardIndex = -1;
    // ターゲット候補
    std::vector<std::shared_ptr<Character>> m_targetCandidates;
    // 選択ターゲット
    std::vector<std::shared_ptr<Character>> m_selectedTargets;
    // アクションデータ
    std::optional<Action> m_action;
	// 決定ボタン
	CircleButton m_decisionButton;
	// ターン終了ボタン
	CircleButton m_turnEndButton;
    // ターン終了確認用
    bool m_requestTurnEnd;

// 内部処理
    // カード選択
    void SelectCard(sf::RenderWindow& window);
    // ターゲット選択
    void SelectTarget(sf::RenderWindow& window);
    //  クリック判定
    int GetClickHandIndex(sf::RenderWindow& window) const;
    // 決定ボタンがクリックされたか
    bool IsDecisionButtonClicked(sf::RenderWindow& window) const;
    // 終了ボタンが押されているか確認
    bool IsTurnEndButtonClicked(sf::RenderWindow& window) const;
};


.cpp
#include "UserController.h"
#include "../../Card/CardManager/CardManager.h"

UserController::UserController()
	:m_phase(PlayerSelectPhase::SELECT_CARD),
	m_decisionButton(40.0f,{ 860.0f, 525.0f }),
	m_turnEndButton(40.0f, { 1000.0f, 525.0f }),
	m_requestTurnEnd(false)
{
}

// アクションキャラのセット
void UserController::SetActionCharacter(const std::shared_ptr<Character>& character)
{
    m_actionCharacter = character;
}

// ターゲット候補のセット
void UserController::SetTargetCandidates(const std::vector<std::shared_ptr<Character>>& targets)
{
    m_targetCandidates = targets;
}

// 更新
void UserController::Update(sf::RenderWindow& window)
{

    // ターン終了ボタン
    if (IsTurnEndButtonClicked(window))
    {
        m_requestTurnEnd = true;
        return;
    }

    switch (m_phase)
    {
    case PlayerSelectPhase::SELECT_CARD:
        SelectCard(window);
        break;

    case PlayerSelectPhase::SELECT_TARGET:
        SelectTarget(window);
        break;

    case PlayerSelectPhase::CONFIRM:
        // アクション作成
        m_action = Action{
            m_actionCharacter,
            m_selectedTargets,
            *m_selectedCard,
        };
        break;
    }
}

void UserController::Draw(sf::RenderWindow& window) const
{
	// 決定ボタン描画
	m_decisionButton.Draw(window);
	// ターン終了ボタン描画
	m_turnEndButton.Draw(window);
}


// アクションがあるか
bool UserController::HasAction() const
{
    return m_action.has_value();
}

// アクションを取り出す
Action UserController::PopAction()
{
    Action act = *m_action;
    m_action.reset();

    m_selectedTargets.clear();
    m_selectedCard.reset();
    m_phase = PlayerSelectPhase::SELECT_CARD;

    return act;
}

bool UserController::IsTurnEndRequested() const
{
    return m_requestTurnEnd;
}

void UserController::ResetTurnEndRequest()
{
    m_requestTurnEnd = false;
}

// カード選択
void UserController::SelectCard(sf::RenderWindow& window)
{
    // 左クリック
    if (sf::Mouse::isButtonPressed(sf::Mouse::Button::Left))
    {
        int index = GetClickHandIndex(window);

        if (index >= 0)
        {
            m_selectedCardIndex = index;

            const auto& hand = CardManager::GetInstance().GetHandCard();
            m_selectedCard = hand[m_selectedCardIndex]->GetCardState();

            // デバッグ
            std::cout << "選択中カード index: " << m_selectedCardIndex << std::endl;
        }
    }

    // 決定ボタン
    sf::Vector2f mousePos = window.mapPixelToCoords(sf::Mouse::getPosition(window));
    bool leftClick = sf::Mouse::isButtonPressed(sf::Mouse::Button::Left);
    if (m_decisionButton.IsClicked(mousePos, leftClick) && m_selectedCard.has_value())
    {
        m_phase = PlayerSelectPhase::SELECT_TARGET;
    }
}

// ターゲット選択
void UserController::SelectTarget(sf::RenderWindow& window)
{

    // --- 単体選択 ---
    if (m_selectedCard->targetType == TargetType::OPPONENT ||
        m_selectedCard->targetType == TargetType::ALLY)
    {
        auto target = TargetSelect::SelectSingle(m_targetCandidates, window);

        if (target)
        {
            m_selectedTargets.clear();
            m_selectedTargets.push_back(target);

            m_phase = PlayerSelectPhase::CONFIRM;
        }
    }
    // --- 全体 ---
    else if (m_selectedCard->targetType == TargetType::OPPONENT_ALL ||
        m_selectedCard->targetType == TargetType::ALLY_ALL)
    {
        // 誰かをクリックしたら確定、という仕様
        if (sf::Mouse::isButtonPressed(sf::Mouse::Button::Left))
        {
            m_selectedTargets =
                TargetSelect::SelectAll(m_targetCandidates);

            m_phase = PlayerSelectPhase::CONFIRM;
        }
    }
    // --- 自分 ---
    else if (m_selectedCard->targetType == TargetType::SELF)
    {
        auto self = TargetSelect::SelectSelf(m_actionCharacter);

        if (self)
        {
            m_selectedTargets.clear();
            m_selectedTargets.push_back(self);

            m_phase = PlayerSelectPhase::CONFIRM;
        }
    }
}

// クリックされた手札のインデックス取得
int UserController::GetClickHandIndex(sf::RenderWindow& window) const
{
	// カードサイズ
    constexpr float CARD_W = 120.0f;
    constexpr float CARD_H = 160.0f;

	// 手札のベース座標
    float startX = 300.0f;
    float y = 300.0f;

	// マウス座標取得
    auto mouse = sf::Mouse::getPosition(window);
    sf::Vector2f mousePos(static_cast<float>(mouse.x), static_cast<float>(mouse.y));

	// 手札取得
    const auto& hand = CardManager::GetInstance().GetHandCard();

	// 各カードと当たり判定
    for (size_t i = 0; i < hand.size(); i++)
    {
        sf::FloatRect rect(
            { startX + i * 130.0f, y },
            { CARD_W, CARD_H }
        );

        if (rect.contains(mousePos))
        {
            return static_cast<int>(i);
        }
    }

    return -1;
}

// 決定ボタンがクリックされたか
bool UserController::IsDecisionButtonClicked(sf::RenderWindow& window) const
{
    constexpr sf::FloatRect decisionButton(
        { 800.f, 500.f },   // 座標
        { 120.f, 50.f }     // サイズ
    );

    if (sf::Mouse::isButtonPressed(sf::Mouse::Button::Left))
    {
        auto mouse = sf::Mouse::getPosition(window);
        sf::Vector2f pos(static_cast<float>(mouse.x), static_cast<float>(mouse.y));
        return decisionButton.contains(pos);
    }
    return false;
}

// 終了ボタンが押されているか確認
bool UserController::IsTurnEndButtonClicked(sf::RenderWindow& window) const
{
	// マウス座標取得
    sf::Vector2f mousePos = window.mapPixelToCoords(sf::Mouse::getPosition(window));
    bool leftClick = sf::Mouse::isButtonPressed(sf::Mouse::Button::Left);
	// ターン終了ボタンクリック判定
    if (m_turnEndButton.IsClicked(mousePos, leftClick))
    {
		return true;
    }
    else {
		return false;
    }

}


2026/01/19
デッキ編成画面の実装

次回の予定
残りカード枚数を「×ｎ枚」と表示

2026/01/19
バトルシステムの構築

新仕様の詳細はエクセル参照


2026/01/23
ユーザーコントローラーの実装

次の作業

battleSystemの実装
　ユーザーコントローラーとの接続
　コスト実装
　描画

キャラクターファクトリーの修正
キャラクターCSVの修正

cardManagerにカードID一覧所持実装（メソッドはある）


2026/01/23

battleSystemの実装
　ユーザーコントローラーとの接続
　コスト実装

キャラクターファクトリーの修正
キャラクターCSVの修正


2026/01/25

描画系の実装
キャラクターの選択可能

次の作業
・カードの描画（山札、墓地、手札）
・カードの選択（メソッドあり）
・ターゲット選択（メソッドあり）

（・ターゲットのフォーカス描画（メソッドあり）
・コスト表示（メソッドあり）
・キャラクターにアップ
・攻撃時の画像切り替え同期
）

2026/01/26
・描画系の実装
・選択系の実装

次の作業
・カードの破棄などのエラー解消
・コストの描画
・プレイヤーターンの実装完了
・エネミーターンの実装
・ターンループの完了

2026/01/27
実装内容
・カード破棄のエラー開所
・ユーザーターンの実装完了（描画は簡易）
・エネミーターンの実装
・ソースの整理

次の作業
・ターンループの完了
（現状、途中で進行が停止。原因未特定）